!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("immutable")):"function"==typeof define&&define.amd?define(["immutable"],t):"object"==typeof exports?exports["meteor-immutable-observer"]=t(require("immutable")):e["meteor-immutable-observer"]=t(e.Immutable)}(this,function(e){return function(e){function t(o){if(n[o])return n[o].exports;var u=n[o]={exports:{},id:o,loaded:!1};return e[o].call(u.exports,u,u.exports,t),u.loaded=!0,u.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}t.__esModule=!0;var u=n(6),r=o(u),i=n(5),d=o(i),f=n(4),a=o(f);t["default"]={Map:r["default"],List:d["default"],IndexBy:a["default"]},e.exports=t["default"]},function(t,n){t.exports=e},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function u(e,t){return e instanceof i["default"].Collection&&t instanceof i["default"].Collection&&Object.getPrototypeOf(e)===Object.getPrototypeOf(t)?e.withMutations(function(n){e.forEach(function(e,o){t.has(o)||n["delete"](o)}),t.forEach(function(t,o){e.has(o)?n.set(o,u(e.get(o),t)):n.set(o,t)})}):e===t?e:t}t.__esModule=!0,t["default"]=u;var r=n(1),i=o(r);e.exports=t["default"]},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function u(e,t){return e.withMutations(function(e){for(var n in t)if(t.hasOwnProperty(n)){var o=t[n];void 0===o?e["delete"](n):e.update(n,function(e){return f["default"](e,i["default"].fromJS(o))})}})}t.__esModule=!0,t["default"]=u;var r=n(1),i=o(r),d=n(2),f=o(d);e.exports=t["default"]},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function u(e,t){function n(e){o=e,u.changed()}if(Tracker.active)throw new Error("This can't be used inside reactive computations; it could cause infinite invalidate loops");"string"==typeof t||"number"==typeof t?!function(){var e=t;t=function(t){return t.get(e)}}():t instanceof Array&&!function(){var e=t;t=function(t){return t.getIn(e)}}();var o=void 0,u=new Tracker.Dependency,r={},d={},f=e.observeChanges({added:function(e,u){u._id=e;var f=i["default"].fromJS(u),a=t(f);if(d){if(d.hasOwnProperty(a))throw new Error("Key ("+a+") for added document _id "+e+" conflicts with a pre-existing document");d[a]=f}else{if(o.has(a))throw new Error("Key ("+a+") for added document _id "+e+" conflicts with a pre-existing document");n(o.set(a,f))}r[e]=a},changed:function(e,u){var i=r[e],d=a["default"](o.get(i),u),f=t(d);if(i!==f){if(o.has(f))throw new Error("Key for document _id "+e+" has changed from "+i+" to "+f+", which conflicts with a pre-existing document, because of changed fields: "+JSON.stringify(u));r[e]=f,n(o.withMutations(function(e){e["delete"](i),e.set(f,d)}))}else n(o.set(i,d))},removed:function(e){var t=r[e];delete r[e],n(o["delete"](t))}});return o=i["default"].Map(d),d=void 0,{documents:function(){return u.depend(),o},stop:function(){f.stop()}}}t.__esModule=!0,t["default"]=u;var r=n(1),i=o(r),d=n(2),f=(o(d),n(3)),a=o(f);e.exports=t["default"]},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function u(e){function t(e){n=e,o.changed()}if(Tracker.active)throw new Error("This can't be used inside reactive computations; it could cause infinite invalidate loops");var n=void 0,o=new Tracker.Dependency,u=[],r=e.observe({addedAt:function(e,o,r){u?u.splice(o,0,i["default"].fromJS(e)):t(n.splice(o,0,i["default"].fromJS(e)))},changedAt:function(e,o,u){t(n.update(u,function(t){return f["default"](t,i["default"].fromJS(e))}))},removedAt:function(e,o){t(n.splice(o,1))},movedTo:function(e,o,u,r){var i=n.get(o);t(n.splice(o,1).splice(u,0,i))}});return n=i["default"].List(u),u=void 0,{documents:function(){return o.depend(),n},stop:function(){r.stop()}}}t.__esModule=!0,t["default"]=u;var r=n(1),i=o(r),d=n(2),f=o(d);e.exports=t["default"]},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{"default":e}}function u(e){function t(e){n=e,o.changed()}if(Tracker.active)throw new Error("This can't be used inside reactive computations; it could cause infinite invalidate loops");var n=void 0,o=new Tracker.Dependency,u={},r=e.observeChanges({added:function(e,o){o._id=e,u?u[e]=i["default"].fromJS(o):t(n.set(e,i["default"].fromJS(o)))},changed:function(e,o){t(n.update(e,function(e){return a["default"](e,o)}))},removed:function(e){t(n["delete"](e))}});return n=i["default"].Map(u),u=void 0,{documents:function(){return o.depend(),n},stop:function(){r.stop()}}}t.__esModule=!0,t["default"]=u;var r=n(1),i=o(r),d=n(2),f=(o(d),n(3)),a=o(f);e.exports=t["default"]}])});